import { NextRequest, NextResponse } from 'next/server';
import { MongoClient } from 'mongodb';
import { GoogleGenerativeAI } from '@google/generative-ai';

/**
 * API endpoint to generate interview questions using Google Gemini
 * 
 * This endpoint:
 * 1. Receives user information and sessionId
 * 2. Calls Google Gemini API to generate personalized questions
 * 3. Saves questions to Questions collection in MongoDB Atlas
 * 4. Returns the generated questions
 */
export async function POST(request: NextRequest) {
  let client: MongoClient | null = null;
  
  try {
    const { sessionId, userInfo } = await request.json();
    
    console.log('ü§ñ GenerateQuestions API called for:', { sessionId, userInfo });

    // Validate required fields
    if (!sessionId || !userInfo) {
      console.log('‚ùå Missing required fields');
      return NextResponse.json(
        { error: 'Missing required fields: sessionId, userInfo' },
        { status: 400 }
      );
    }

    // Initialize Google Gemini
    const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY || '');
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

    console.log('‚úÖ Google Gemini initialized');

    // Generate questions using Gemini
    const questions = await generateQuestionsWithGemini(model, userInfo);
    
    console.log('‚úÖ Questions generated by Gemini:', questions.length);

    // Connect to MongoDB Atlas
    const mongoUri = process.env.MONGODB_URI;
    if (!mongoUri) {
      console.log('‚ùå MongoDB URI not configured');
      return NextResponse.json(
        { error: 'Database connection not configured' },
        { status: 500 }
      );
    }

    client = new MongoClient(mongoUri);
    await client.connect();
    console.log('‚úÖ Connected to MongoDB Atlas');

    const db = client.db('interview_system');
    const collection = db.collection('questions');

    // Create questions document
    const questionsDocument = {
      sessionId,
      userInfo,
      questions,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Insert or update questions
    const result = await collection.findOneAndUpdate(
      { sessionId },
      { $set: questionsDocument },
      { upsert: true, returnDocument: 'after' }
    );

    console.log('‚úÖ Questions saved to database');

    return NextResponse.json({
      success: true,
      message: 'Questions generated successfully',
      sessionId,
      questions: questions,
      totalQuestions: questions.length
    });

  } catch (error) {
    console.error('‚ùå Error generating questions:', error);
    return NextResponse.json(
      { 
        error: 'Failed to generate questions',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  } finally {
    if (client) {
      await client.close();
      console.log('üîå MongoDB connection closed');
    }
  }
}

/**
 * Generate interview questions using Google Gemini AI
 */
async function generateQuestionsWithGemini(model: any, userInfo: any) {
  try {
    const prompt = `
You are an expert interview coach. Generate ${getQuestionCount(userInfo.interviewType)} high-quality interview questions for a candidate with the following profile:

**Candidate Profile:**
- Name: ${userInfo.name}
- Target Role: ${userInfo.role}
- Interview Type: ${userInfo.interviewType}
- Skill Level: ${userInfo.skillLevel}
- Experience: ${userInfo.experience || 'Not specified'}

**Requirements:**
1. Questions should be appropriate for the ${userInfo.skillLevel} level
2. Mix of ${userInfo.interviewType} questions
3. Questions should be specific to the ${userInfo.role} role
4. Include both technical and behavioral questions if applicable
5. Questions should be clear, concise, and professional

**Response Format:**
Return ONLY a JSON array of question objects. Each question object should have:
- "id": unique identifier (number)
- "text": the question text
- "type": question type ("technical", "behavioral", "case-study", "situational")
- "difficulty": difficulty level ("easy", "medium", "hard")
- "category": question category (e.g., "programming", "problem-solving", "leadership")

Example format:
[
  {
    "id": 1,
    "text": "Can you walk me through your experience with [specific technology]?",
    "type": "technical",
    "difficulty": "medium",
    "category": "technical-skills"
  }
]

Generate exactly ${getQuestionCount(userInfo.interviewType)} questions. Return ONLY the JSON array, no additional text.
`;

    console.log('üìù Sending prompt to Gemini:', prompt.substring(0, 200) + '...');

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    console.log('üìã Raw Gemini response:', text.substring(0, 200) + '...');

    // Parse JSON response
    let questions;
    try {
      // Clean the response (remove any markdown formatting)
      const cleanText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      questions = JSON.parse(cleanText);
    } catch (parseError) {
      console.error('‚ùå Failed to parse Gemini response:', parseError);
      console.log('Raw response:', text);
      
      // Fallback: generate questions manually
      questions = generateFallbackQuestions(userInfo);
    }

    // Validate questions structure
    if (!Array.isArray(questions)) {
      console.log('‚ö†Ô∏è Gemini response is not an array, using fallback');
      questions = generateFallbackQuestions(userInfo);
    }

    // Ensure each question has required fields
    questions = questions.map((q: any, index: number) => ({
      id: q.id || index + 1,
      text: q.text || `Question ${index + 1}`,
      type: q.type || 'behavioral',
      difficulty: q.difficulty || 'medium',
      category: q.category || 'general'
    }));

    console.log('‚úÖ Questions processed successfully:', questions.length);
    return questions;

  } catch (error) {
    console.error('‚ùå Error in generateQuestionsWithGemini:', error);
    return generateFallbackQuestions(userInfo);
  }
}

/**
 * Generate fallback questions if Gemini fails
 */
function generateFallbackQuestions(userInfo: any) {
  const questionCount = getQuestionCount(userInfo.interviewType);
  const questions = [];

  const baseQuestions = {
    'software-engineer': [
      "Can you explain your experience with object-oriented programming?",
      "How would you approach debugging a complex issue in production?",
      "Describe a time when you had to learn a new technology quickly.",
      "How do you ensure code quality in your projects?",
      "Explain the difference between synchronous and asynchronous programming."
    ],
    'data-scientist': [
      "Walk me through your experience with machine learning algorithms.",
      "How do you handle missing data in your datasets?",
      "Describe a time when you had to explain complex data insights to non-technical stakeholders.",
      "What's your approach to feature selection in machine learning?",
      "How do you validate the performance of your models?"
    ],
    'product-manager': [
      "How do you prioritize features in a product roadmap?",
      "Describe a time when you had to make a difficult product decision.",
      "How do you gather and analyze user feedback?",
      "Explain your approach to competitive analysis.",
      "How do you work with engineering teams to deliver products?"
    ],
    'default': [
      "Tell me about yourself and your background.",
      "What interests you most about this role?",
      "Describe a challenging project you worked on.",
      "How do you handle working under pressure?",
      "What are your career goals for the next 5 years?"
    ]
  };

  const roleQuestions = baseQuestions[userInfo.role as keyof typeof baseQuestions] || baseQuestions.default;

  for (let i = 0; i < questionCount; i++) {
    questions.push({
      id: i + 1,
      text: roleQuestions[i] || `Question ${i + 1} for ${userInfo.role}`,
      type: i < 2 ? 'technical' : 'behavioral',
      difficulty: 'medium',
      category: userInfo.role
    });
  }

  console.log('üîÑ Generated fallback questions:', questions.length);
  return questions;
}

/**
 * Determine number of questions based on interview type
 */
function getQuestionCount(interviewType: string): number {
  switch (interviewType) {
    case 'technical':
      return 8;
    case 'behavioral':
      return 6;
    case 'mixed':
      return 10;
    case 'case-study':
      return 5;
    default:
      return 7;
  }
}

/**
 * GET endpoint to retrieve questions by sessionId
 */
export async function GET(request: NextRequest) {
  let client: MongoClient | null = null;
  
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    
    console.log('üìñ GetQuestions API called for sessionId:', sessionId);

    if (!sessionId) {
      return NextResponse.json(
        { error: 'SessionId is required' },
        { status: 400 }
      );
    }

    // Connect to MongoDB Atlas
    const mongoUri = process.env.MONGODB_URI;
    if (!mongoUri) {
      return NextResponse.json(
        { error: 'Database connection not configured' },
        { status: 500 }
      );
    }

    client = new MongoClient(mongoUri);
    await client.connect();

    const db = client.db('interview_system');
    const collection = db.collection('questions');

    // Find questions by sessionId
    const questionsData = await collection.findOne({ sessionId });

    if (!questionsData) {
      return NextResponse.json(
        { error: 'Questions not found' },
        { status: 404 }
      );
    }

    console.log('‚úÖ Questions retrieved:', questionsData.questions.length);

    return NextResponse.json({
      success: true,
      questions: questionsData.questions,
      userInfo: questionsData.userInfo
    });

  } catch (error) {
    console.error('‚ùå Error retrieving questions:', error);
    return NextResponse.json(
      { 
        error: 'Failed to retrieve questions',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  } finally {
    if (client) {
      await client.close();
    }
  }
}